import { PedidoRepository } from "../domain/repositories/pedidoRepository";
import { ProductoPedidoRepository } from "../domain/repositories/productoPedidoRepository";
import { PagoRepository } from "../domain/repositories/pagoRepository";
import { MetodoPagoRepository } from "../domain/repositories/metodoPagoRepository";
import { Pedido } from "../domain/models/pedido";
import { Pago } from "../domain/models/pago";
import { PagoDto } from "../domain/dtos/pagoDto";
import { MetodoPago } from "../domain/models/metodoPago";
import { generarReciboPDF } from "../utils/pdfGenerator";
import { TableService } from "./apis/tableService";
import { InventoryService } from "./apis/inventoryService";
import { ClientService } from "./apis/clientService";
import { PriceCalculatorService } from "./priceCalculatorService";
import { Op } from "sequelize";
import { ServiceResult } from "../types/pedido.types";

/**
 * Servicio para gestión de pagos
 * Sigue patrón: Objetos de Resultado con Status y Data en Servicios
 */
export class PagoService {
  private pedidoRepository: PedidoRepository;
  private productoPedidoRepository: ProductoPedidoRepository;
  private pagoRepository: PagoRepository;
  private metodoPagoRepository: MetodoPagoRepository;
  private tableService: TableService;
  private inventoryService: InventoryService;
  private clientService: ClientService;
  private priceCalculatorService: PriceCalculatorService;

  constructor() {
    this.pedidoRepository = new PedidoRepository();
    this.productoPedidoRepository = new ProductoPedidoRepository();
    this.pagoRepository = new PagoRepository();
    this.metodoPagoRepository = new MetodoPagoRepository();
    this.tableService = new TableService();
    this.inventoryService = new InventoryService();
    this.clientService = new ClientService();
    this.priceCalculatorService = new PriceCalculatorService();
  }

  private toDto(pago: Pago):  PagoDto {
    return {
      idPago: pago.idPago,
      urlComprobante: pago.urlComprobante,
      monto: pago.monto,
      fechaPago: pago.fechaPago,
      idPedido: pago.idPedido,
      idMetodoPago: pago.idMetodoPago,
    }
  }

  /**
   * Mapea un pago con sus relaciones a un objeto DTO completo
   */
  private mapPagoConRelaciones(pago: Pago): any {
    return {
      ...this.toDto(pago),
      metodoPago: {
        idMetodoPago: pago.metodoPago?.idMetodo,
        nombre: pago.metodoPago?.nombre
      },
      pedido: {
        idPedido: pago.pedido?.idPedido,
        idUsuario: pago.pedido?.idUsuario,
        total: pago.pedido?.total,
        estado: pago.pedido?.estado,
        fechaPedido: pago.pedido?.fechaPedido,
        direccionEntrega: pago.pedido?.direccionEntrega,
        canalVenta: pago.pedido?.canalVenta,
        idMesa: pago.pedido?.idMesa
      }
    };
  }

  /**
   * Mapea un pago con relaciones a formato reducido para historial
   */
  private mapPagoParaHistorial(pago: Pago): any {
    return {
      ...this.toDto(pago),
      metodoPago: {
        idMetodoPago: pago.metodoPago?.idMetodo,
        nombre: pago.metodoPago?.nombre
      },
      pedido: {
        idPedido: pago.pedido?.idPedido,
        total: pago.pedido?.total,
        estado: pago.pedido?.estado,
        fechaPedido: pago.pedido?.fechaPedido,
        direccionEntrega: pago.pedido?.direccionEntrega
      }
    };
  }

  /**
   * CU39/CU40 - Registrar pago de pedido
   * Retorna objeto con status para que el controlador decida código HTTP
   * 
   * IMPORTANTE: Aquí se hace TODO el proceso:
   * 1. Validar que el pedido pertenezca al usuario
   * 2. Calcular precio final con promociones
   * 3. Obtener dirección (del pedido o del parámetro)
   * 4. Validar stock actual
   * 5. Reducir inventario
   * 6. Registrar pago
   * 7. Cambiar estado a 'pendiente' (pagado, esperando que empleado lo entregue)
   */
  async registrarPagoPedido(
    idPedido: number,
    idUsuario: number,
    idMetodoPago: number,
    direccionEntrega?: string,
    accessToken?: string
  ): Promise<ServiceResult> {
    
    const pedido = await this.pedidoRepository.findById(idPedido);

    if (!pedido) {
      return { 
        status: 404, 
        message: "El pedido no existe" 
      };
    }

    // Validar que el pedido pertenezca al usuario autenticado
    if (pedido.idUsuario !== idUsuario) {
      return {
        status: 403,
        message: "No tiene permiso para pagar este pedido"
      };
    }

    // Solo permitir pago si el pedido está en estado 'sin_confirmar'
    // Si ya está en 'pendiente' o posterior, significa que ya fue procesado
    if (pedido.estado !== 'sin_confirmar') {
      return { 
        status: 400, 
        message: `El pedido no puede ser pagado. Estado actual: ${pedido.estado}` 
      };
    }

    const metodoPago = await this.metodoPagoRepository.findById(idMetodoPago);
    if (!metodoPago) {
      return { 
        status: 400, 
        message: "Método de pago no válido" 
      };
    }

    const productos = await this.productoPedidoRepository.findByPedido(idPedido);

    if (productos.length === 0) {
      return { 
        status: 400, 
        message: "El pedido no tiene productos" 
      };
    }

    // PASO 1: Re-calcular total con promociones activas
    let totalConPromociones = 0;
    for (const productoPedido of productos) {
      try {
        const calculoPromocion = await this.priceCalculatorService.calcularPrecioConPromocion(
          productoPedido.idProducto,
          productoPedido.cantidad,
          accessToken
        );

        const subtotalConPromocion = calculoPromocion.precioFinal * productoPedido.cantidad;
        totalConPromociones += subtotalConPromocion;

        // Actualizar precio unitario y subtotal con la promoción aplicada
        await this.productoPedidoRepository.update(productoPedido.idProductoPedido, {
          precioUnitario: calculoPromocion.precioFinal,
          subtotal: subtotalConPromocion
        });
      } catch (error) {
        console.error(`Error al calcular promoción para producto ${productoPedido.idProducto}:`, error);
        totalConPromociones += Number(productoPedido.subtotal);
      }
    }
    totalConPromociones = Number(totalConPromociones.toFixed(2));

    // PASO 2: Determinar dirección de entrega
    // Prioridad: 1) direccionEntrega proporcionada, 2) dirección del pedido, 3) vacía
    let direccionFinal = direccionEntrega || pedido.direccionEntrega || '';

    // PASO 3: Validar stock actual ANTES de procesar el pago
    // Esto evita pagos de productos que ya no están disponibles
    for (const productoPedido of productos) {
      const productoActual = await this.inventoryService.getProductoById(
        productoPedido.idProducto,
        accessToken
      );

      if (!productoActual || !productoActual.activo) {
        return {
          status: 400,
          message: `El producto con ID ${productoPedido.idProducto} ya no está disponible`
        };
      }

      if (productoActual.stockActual < productoPedido.cantidad) {
        return {
          status: 400,
          message: `Stock insuficiente para el producto con ID ${productoPedido.idProducto}. Disponible: ${productoActual.stockActual}, Requerido: ${productoPedido.cantidad}`
        };
      }
    }

    // PASO CRÍTICO: Reducir stock en inventario de forma atómica
    // Solo después de validar que todo está disponible
    try {
      for (const productoPedido of productos) {
        await this.inventoryService.reducirStock(
          productoPedido.idProducto,
          productoPedido.cantidad,
          accessToken
        );
      }
    } catch (stockError: any) {
      return {
        status: 500,
        message: `Error al reducir inventario: ${stockError.message}`
      };
    }

    // PASO 5: Registrar el pago
    const pago = await this.pagoRepository.create({
      idPedido,
      idMetodoPago,
      monto: totalConPromociones,
      fechaPago: new Date(),
      urlComprobante: ''
    });

    // PASO 6: Actualizar pedido a 'pendiente' con total y dirección
    // Nota: Queda 'pendiente' hasta que un empleado lo marque como 'entregado'
    await this.pedidoRepository.update(idPedido, {
      total: totalConPromociones,
      estado: 'pendiente',
      direccionEntrega: direccionFinal
    });

    const pedidoActualizado = await this.pedidoRepository.findById(idPedido) as Pedido;

    // Generar recibo PDF
    let rutaPDF: string;
    let nombreMesa: string | undefined;

    if (pedidoActualizado.idMesa) {
      try {
        const mesas = await this.tableService.getAllMesas();
        const mesa = mesas.find((m: any) => m.idMesa === pedidoActualizado.idMesa);
        if (mesa) {
          nombreMesa = `Mesa ${mesa.numeroMesa}`;
        }
      } catch (error) {
        console.error("Error al obtener información de mesa:", error);
      }
    }

    try {
      rutaPDF = await generarReciboPDF({
        pedido: pedidoActualizado,
        productos: productos,
        nombreMesa: nombreMesa
      });

      await this.pagoRepository.update(pago.idPago, {
        urlComprobante: rutaPDF
      });
    } catch (error: any) {
      console.error("Error al generar PDF:", error);
      return { 
        status: 500, 
        message: "Pago registrado pero error al generar recibo PDF" 
      };
    }

    // Obtener el pago actualizado con el comprobante
    const pagoFinal = await this.pagoRepository.findById(pago.idPago) as Pago;

    return {
      status: 201,
      data: {
        success: true,
        message: "Pago registrado exitosamente",
        data: {
          pedido: {
            idPedido: pedidoActualizado.idPedido,
            total: pedidoActualizado.total,
            estado: pedidoActualizado.estado,
            canalVenta: pedidoActualizado.canalVenta,
            fechaPedido: pedidoActualizado.fechaPedido,
            idMesa: pedidoActualizado.idMesa
          },
          pago: this.toDto(pagoFinal),
          rutaPDF
        }
      }
    };
  }

  /**
   * CU39 - Listar pedidos por pagar (sin_confirmar)
   * 
   * @returns Array de pedidos pendientes de pago
   */
  async listarPedidosPorPagar(): Promise<Pedido[]> {
    const pedidos = await this.pedidoRepository.findAll({
      where: {
        estado: 'sin_confirmar'
      },
      order: [['fechaPedido', 'DESC']]
    });

    return pedidos;
  }

  /**
   * CU40 - Listar métodos de pago disponibles
   * 
   * @returns Array de métodos de pago
   */
  async listarMetodosPago(): Promise<MetodoPago[]> {
    const metodos = await this.metodoPagoRepository.findAll();
    return metodos;
  }

  /**
   * Obtener todos los pagos (Solo administradores)
   * 
   * @returns Lista completa de todos los pagos con información de pedido y método de pago
   */
  async obtenerTodosLosPagos(): Promise<any[]> {
    const pagos = await this.pagoRepository.findAllWithRelations({}, {});
    return pagos.map(pago => this.mapPagoConRelaciones(pago));
  }

  /**
   * Crear nuevo método de pago
   */
  async crearMetodoPago(nombre: string): Promise<ServiceResult> {
    const metodoExistente = await this.metodoPagoRepository.findByNombre(nombre);
    
    if (metodoExistente) {
      return {
        status: 400,
        message: "Ya existe un método de pago con ese nombre"
      };
    }

    const nuevoMetodo = await this.metodoPagoRepository.create({ nombre });

    return {
      status: 201,
      data: {
        success: true,
        message: "Método de pago creado exitosamente",
        data: {
          idMetodo: nuevoMetodo.idMetodo,
          nombre: nuevoMetodo.nombre
        }
      }
    };
  }

  /**
   * Obtener método de pago por ID
   */
  async obtenerMetodoPagoPorId(idMetodo: number): Promise<MetodoPago | null> {
    return await this.metodoPagoRepository.findById(idMetodo);
  }

  /**
   * Actualizar método de pago
   */
  async actualizarMetodoPago(idMetodo: number, nombre: string): Promise<ServiceResult> {
    const metodo = await this.metodoPagoRepository.findById(idMetodo);

    if (!metodo) {
      return {
        status: 404,
        message: "Método de pago no encontrado"
      };
    }

    const metodoConMismoNombre = await this.metodoPagoRepository.findByNombre(nombre);
    
    if (metodoConMismoNombre && metodoConMismoNombre.idMetodo !== idMetodo) {
      return {
        status: 400,
        message: "Ya existe otro método de pago con ese nombre"
      };
    }

    await this.metodoPagoRepository.update(idMetodo, { nombre });
    const metodoActualizado = await this.metodoPagoRepository.findById(idMetodo);

    return {
      status: 200,
      data: {
        success: true,
        message: "Método de pago actualizado exitosamente",
        data: {
          idMetodo: metodoActualizado!.idMetodo,
          nombre: metodoActualizado!.nombre
        }
      }
    };
  }

  /**
   * Eliminar método de pago
   */
  async eliminarMetodoPago(idMetodo: number): Promise<ServiceResult> {
    const metodo = await this.metodoPagoRepository.findById(idMetodo);

    if (!metodo) {
      return {
        status: 404,
        message: "Método de pago no encontrado"
      };
    }

    // Verificar si hay pagos con este método
    const pagosConMetodo = await this.pagoRepository.findAll({
      where: { idMetodoPago: idMetodo }
    });

    if (pagosConMetodo.length > 0) {
      return {
        status: 400,
        message: "No se puede eliminar el método de pago porque tiene pagos asociados"
      };
    }

    await this.metodoPagoRepository.delete(idMetodo);

    return {
      status: 200,
      data: {
        success: true,
        message: "Método de pago eliminado exitosamente"
      }
    };
  }

  /**
   * CU041 - Consultar historial de pagos
   * Obtiene el historial de pagos con filtros opcionales
   * 
   * @param filtros - Filtros opcionales (fechaInicio, fechaFin, idMetodoPago, estado)
   * @returns Lista de pagos con información del pedido y método de pago
   */
  async obtenerHistorialPagos(filtros: {
    fechaInicio?: Date;
    fechaFin?: Date;
    idMetodoPago?: number;
    estado?: string;
  }): Promise<any[]> {
    const whereClausePago: any = {};
    const whereClausePedido: any = {};

    // Filtro por rango de fechas
    if (filtros.fechaInicio && filtros.fechaFin) {
      whereClausePago.fechaPago = {
        [Op.between]: [filtros.fechaInicio, filtros.fechaFin]
      };
    } else if (filtros.fechaInicio) {
      whereClausePago.fechaPago = {
        [Op.gte]: filtros.fechaInicio
      };
    } else if (filtros.fechaFin) {
      whereClausePago.fechaPago = {
        [Op.lte]: filtros.fechaFin
      };
    }

    // Filtro por método de pago
    if (filtros.idMetodoPago) {
      whereClausePago.idMetodoPago = filtros.idMetodoPago;
    }

    // Filtro por estado del pedido
    if (filtros.estado) {
      whereClausePedido.estado = filtros.estado;
    }

    // Obtener pagos con información del pedido y método de pago
    const pagos = await this.pagoRepository.findAllWithRelations(whereClausePago, whereClausePedido);
    return pagos.map(pago => this.mapPagoParaHistorial(pago));
  }

  /**
   * CU041 - Obtener detalle de un pago específico
   * 
   * @param idPago - ID del pago a consultar
   * @returns Información detallada del pago
   */
  async obtenerDetallePago(idPago: number): Promise<any> {
    const pago = await this.pagoRepository.findByIdWithRelations(idPago);

    if (!pago) {
      throw new Error("Pago no encontrado");
    }

    return this.mapPagoConRelaciones(pago);
  }
}
