import { PedidoRepository } from "../domain/repositories/pedidoRepository";
import { ProductoPedidoRepository } from "../domain/repositories/productoPedidoRepository";
import { PagoRepository } from "../domain/repositories/pagoRepository";
import { MetodoPagoRepository } from "../domain/repositories/metodoPagoRepository";
import { InventoryService } from "./apis/inventoryService";
import { ClientService } from "./apis/clientService";
import { sendOrderConfirmationEmail } from "./apis/emailService";
import { PriceCalculatorService } from "./priceCalculatorService";
import { Pedido } from "../domain/models/pedido";
import { ProductoPedido } from "../domain/models/productoPedido";
import { Pago } from "../domain/models/pago";
import { MetodoPago } from "../domain/models/metodoPago";
import { TableService } from "./apis/tableService";
import { generarReciboPDF } from "../utils/pdfGenerator";
import { ServiceResult } from "../types/pedido.types";

/**
 * Servicio para gestión de pedidos (carritos de compra)
 * Sigue patrón: Objetos de Resultado con Status y Data en Servicios
 */
/**
 * Interface para datos de confirmación de pedido
 * Nota: La dirección es opcional - si no se proporciona, se usa la del cliente
 */
export interface ConfirmarPedidoData {
  direccionEntrega?: string; // Opcional - se obtiene del cliente si no se proporciona
}

/**
 * Resultado de confirmar pedido
 */
export interface ConfirmarPedidoResult {
  pedido: Pedido;
  pago: Pago;
  mensaje: string;
}

/**
 * Interface para producto en creación de pedido (CU48)
 */
export interface ProductoPedidoInput {
  idProducto: number;
  cantidad: number;
}

/**
 * Resultado de crear pedido de cliente (CU48)
 */
export interface CrearPedidoClienteResult {
  pedido: Pedido;
  productos: ProductoPedido[];
  rutaPDF: string;
  mensaje: string;
}

export class PedidoService {
  private pedidoRepository: PedidoRepository;
  private productoPedidoRepository: ProductoPedidoRepository;
  private pagoRepository: PagoRepository;
  private metodoPagoRepository: MetodoPagoRepository;
  private inventoryService: InventoryService;
  private clientService: ClientService;
  private priceCalculatorService: PriceCalculatorService;
  private tableService: TableService;

  constructor() {
    this.pedidoRepository = new PedidoRepository();
    this.productoPedidoRepository = new ProductoPedidoRepository();
    this.pagoRepository = new PagoRepository();
    this.metodoPagoRepository = new MetodoPagoRepository();
    this.inventoryService = new InventoryService();
    this.clientService = new ClientService();
    this.priceCalculatorService = new PriceCalculatorService();
    this.tableService = new TableService();
  }

  /**
   * Convierte un Pedido a DTO
   */
  private pedidoToDto(pedido: Pedido): any {
    return {
      idPedido: pedido.idPedido,
      idUsuario: pedido.idUsuario,
      total: pedido.total,
      estado: pedido.estado,
      canalVenta: pedido.canalVenta,
      fechaPedido: pedido.fechaPedido,
      direccionEntrega: pedido.direccionEntrega,
      idMesa: pedido.idMesa
    };
  }

  /**
   * Convierte un ProductoPedido a DTO
   */
  private productoPedidoToDto(productoPedido: ProductoPedido): any {
    return {
      idProductoPedido: productoPedido.idProductoPedido,
      idPedido: productoPedido.idPedido,
      idProducto: productoPedido.idProducto,
      cantidad: productoPedido.cantidad,
      precioUnitario: productoPedido.precioUnitario,
      subtotal: productoPedido.subtotal
    };
  }

  /**
   * CU022 - Añadir productos al carrito
   * Retorna objeto con status para que el controlador decida código HTTP
   */
  async agregarProductoAlCarrito(
    idUsuario: number,
    idProducto: number,
    cantidad: number,
    accessToken?: string
  ): Promise<ServiceResult> {
    
    // Validación de cantidad
    if (cantidad <= 0) {
      return { 
        status: 400, 
        message: "La cantidad debe ser mayor a 0" 
      };
    }

    // Validar que el producto exista y esté activo
    // Nota: NO validamos stock aquí, se validará al confirmar el pedido
    const producto = await this.inventoryService.getProductoById(idProducto, accessToken);
    
    if (!producto || !producto.activo) {
      return { 
        status: 404, 
        message: "Producto no disponible actualmente" 
      };
    }

    // Buscar o crear carrito sin confirmar
    let pedidoPendiente = await this.pedidoRepository.findOne({
      where: {
        idUsuario,
        estado: 'sin_confirmar'
      }
    });

    if (!pedidoPendiente) {
      pedidoPendiente = await this.pedidoRepository.create({
        idUsuario,
        total: 0,
        canalVenta: 'web',
        estado: 'sin_confirmar',
        fechaPedido: new Date()
      });
    }

    // Agregar o actualizar producto en carrito
    const { productoPedido, pedidoActualizado } = await this.agregarOActualizarProducto(
      pedidoPendiente.idPedido,
      idProducto,
      cantidad,
      producto.precio
    );

    const productos = await this.productoPedidoRepository.findByPedido(pedidoPendiente.idPedido);

    return {
      status: 200,
      data: {
        success: true,
        message: "Producto añadido al carrito",
        data: {
          pedido: {
            ...this.pedidoToDto(pedidoActualizado),
            cantidadProductos: productos.length
          },
          productoPedido: this.productoPedidoToDto(productoPedido)
        }
      }
    };
  }

  /**
   * Método privado para agregar o actualizar producto en pedido
   * Elimina duplicación de código entre agregarProductoAlCarrito y agregarProductoAPedido
   */
  private async agregarOActualizarProducto(
    idPedido: number,
    idProducto: number,
    cantidad: number,
    precioUnitario: number
  ): Promise<{ productoPedido: ProductoPedido; pedidoActualizado: Pedido }> {
    const productoExistente = await this.productoPedidoRepository.findOne({
      where: { idPedido, idProducto }
    });

    let productoPedido: ProductoPedido;

    if (productoExistente) {
      const nuevaCantidad = productoExistente.cantidad + cantidad;
      const nuevoSubtotal = nuevaCantidad * precioUnitario;
      
      await this.productoPedidoRepository.update(
        productoExistente.idProductoPedido,
        {
          cantidad: nuevaCantidad,
          subtotal: nuevoSubtotal,
          precioUnitario
        }
      );

      productoPedido = await this.productoPedidoRepository.findById(
        productoExistente.idProductoPedido
      ) as ProductoPedido;
    } else {
      const subtotal = cantidad * precioUnitario;
      
      productoPedido = await this.productoPedidoRepository.create({
        idPedido,
        idProducto,
        cantidad,
        precioUnitario,
        subtotal
      });
    }

    // Actualizar total del pedido
    const productosDelPedido = await this.productoPedidoRepository.findByPedido(idPedido);
    const nuevoTotal = productosDelPedido.reduce(
      (sum, prod) => sum + Number(prod.subtotal),
      0
    );

    await this.pedidoRepository.update(idPedido, { total: nuevoTotal });
    const pedidoActualizado = await this.pedidoRepository.findById(idPedido) as Pedido;

    return { productoPedido, pedidoActualizado };
  }

  /**
   * Obtener el carrito actual del usuario
   * 
   * @param idUsuario - ID del usuario autenticado
   * @returns Pedido pendiente con sus productos o null si no existe
   */
  async obtenerCarritoActual(idUsuario: number): Promise<Pedido | null> {
    const pedidoPendiente = await this.pedidoRepository.findOne({
      where: {
        idUsuario,
        estado: 'sin_confirmar'
      },
      include: [ProductoPedido]
    });

    return pedidoPendiente;
  }

  /**
   * Obtener los productos del carrito
   * 
   * @param idUsuario - ID del usuario autenticado
   * @returns Array de productos del pedido
   */
  async obtenerProductosDelCarrito(idUsuario: number): Promise<ProductoPedido[]> {
    const carrito = await this.obtenerCarritoActual(idUsuario);
    
    if (!carrito) {
      return [];
    }

    return await this.productoPedidoRepository.findByPedido(carrito.idPedido);
  }

  /**
   * CU035 - Registrar pedido de cliente
   * Confirma el carrito como pedido finalizado
   */
  async confirmarPedido(
    idUsuario: number,
    data: ConfirmarPedidoData,
    accessToken?: string
  ): Promise<ServiceResult> {
    
    // Validar que el usuario esté registrado como cliente
    const cliente = await this.clientService.getClientById(idUsuario, accessToken);
    if (!cliente) {
      return { 
        status: 403, 
        message: "El usuario no está registrado como cliente" 
      };
    }

    // Obtener el carrito pendiente del usuario
    const carritoPendiente = await this.obtenerCarritoActual(idUsuario);

    if (!carritoPendiente) {
      return { 
        status: 400, 
        message: "No hay productos disponibles para realizar pedidos" 
      };
    }

    const productosDelPedido = await this.productoPedidoRepository.findByPedido(
      carritoPendiente.idPedido
    );

    if (productosDelPedido.length === 0) {
      return { 
        status: 400, 
        message: "No hay productos disponibles para realizar pedidos" 
      };
    }

    // Validar que los productos sigan disponibles y con stock
    const validacion = await this.validarDisponibilidadProductos(productosDelPedido, accessToken);
    if (validacion.status !== 200) {
      return validacion;
    }

    // Calcular total con promociones activas
    const totalConPromociones = await this.calcularTotalConPromociones(
      productosDelPedido,
      accessToken
    );

    // Determinar dirección de entrega
    let direccionEntrega = data.direccionEntrega;
    if (!direccionEntrega) {
      // Si no se proporciona, obtener del cliente
      direccionEntrega = cliente.direccion || '';
    }

    // Actualizar pedido a estado 'pendiente' (confirmado, esperando pago)
    // Nota: El stock NO se reduce aquí, se reducirá al registrar el pago
    await this.pedidoRepository.update(carritoPendiente.idPedido, {
      total: totalConPromociones,
      estado: 'pendiente',
      fechaPedido: new Date(),
      direccionEntrega
    });

    const pedidoFinal = await this.pedidoRepository.findById(
      carritoPendiente.idPedido
    ) as Pedido;

    // Enviar email de confirmación (no bloqueante)
    try {
      const productosParaEmail = productosDelPedido.map(p => ({
        idProducto: p.idProducto,
        cantidad: p.cantidad,
        precioUnitario: p.precioUnitario,
        subtotal: p.subtotal
      }));

      await sendOrderConfirmationEmail({
        email: cliente.email,
        nombreCliente: cliente.nombre,
        numeroPedido: pedidoFinal.idPedido,
        productos: productosParaEmail,
        total: pedidoFinal.total,
        estado: pedidoFinal.estado,
        direccionEntrega: pedidoFinal.direccionEntrega,
        metodoPago: 'Pendiente de pago' // Ya no se registra pago aquí
      });
    } catch (emailError) {
      console.error('Error al enviar email de confirmación:', emailError);
    }

    return {
      status: 200,
      data: {
        success: true,
        message: "Pedido confirmado exitosamente. Ahora puede proceder con el pago.",
        data: {
          pedido: this.pedidoToDto(pedidoFinal)
        }
      }
    };
  }

  /**
   * Validar que todos los productos del pedido sigan disponibles
   */
  private async validarDisponibilidadProductos(
    productosDelPedido: ProductoPedido[],
    accessToken?: string
  ): Promise<ServiceResult> {
    for (const productoPedido of productosDelPedido) {
      const producto = await this.inventoryService.getProductoById(
        productoPedido.idProducto,
        accessToken
      );

      if (!producto || !producto.activo) {
        return {
          status: 400,
          message: `El producto con ID ${productoPedido.idProducto} ya no está disponible`
        };
      }

      if (producto.stockActual < productoPedido.cantidad) {
        return {
          status: 400,
          message: `Stock insuficiente para el producto con ID ${productoPedido.idProducto}`
        };
      }
    }

    return { status: 200 };
  }

  /**
   * Calcular total del pedido aplicando promociones activas
   */
  private async calcularTotalConPromociones(
    productosDelPedido: ProductoPedido[],
    accessToken?: string
  ): Promise<number> {
    let totalFinal = 0;

    for (const productoPedido of productosDelPedido) {
      try {
        // Intentar aplicar promociones
        const calculoPromocion = await this.priceCalculatorService.calcularPrecioConPromocion(
          productoPedido.idProducto,
          productoPedido.cantidad,
          accessToken
        );

        const subtotalConPromocion = calculoPromocion.precioFinal * productoPedido.cantidad;
        totalFinal += subtotalConPromocion;

        // Actualizar el precio unitario y subtotal con la promoción aplicada
        await this.productoPedidoRepository.update(productoPedido.idProductoPedido, {
          precioUnitario: calculoPromocion.precioFinal,
          subtotal: subtotalConPromocion
        });
      } catch (error) {
        // Si falla el cálculo de promoción, usar precio original
        console.error(`Error al calcular promoción para producto ${productoPedido.idProducto}:`, error);
        totalFinal += Number(productoPedido.subtotal);
      }
    }

    return Number(totalFinal.toFixed(2));
  }

  /**
   * CU37 - Agregar productos a un pedido
   * Permite a empleados agregar productos a pedidos existentes
   * 
   * @param idPedido - ID del pedido al que se agregarán productos
   * @param idProducto - ID del producto a agregar
   * @param cantidad - Cantidad del producto
   * @param accessToken - Token de acceso para validaciones
   * @returns Pedido actualizado con producto agregado
   */
  async agregarProductoAPedido(
    idPedido: number,
    idProducto: number,
    cantidad: number,
    accessToken?: string
  ): Promise<{ pedido: Pedido; productoPedido: ProductoPedido; mensaje: string }> {
    
    // Validación de cantidad
    if (cantidad <= 0) {
      throw new Error("La cantidad debe ser mayor a 0");
    }

    // Paso 1: Obtener el pedido en curso
    const pedido = await this.pedidoRepository.findById(idPedido);
    
    if (!pedido) {
      throw new Error("El pedido no existe");
    }

    // Flujo alterno 2: Validar que el pedido no esté cancelado
    if (pedido.estado === 'cancelado') {
      throw new Error("No se pueden agregar productos a un pedido cancelado");
    }

    // Paso 3: Validar que el producto exista y tenga stock
    const producto = await this.inventoryService.getProductoById(idProducto, accessToken);
    
    // Excepción 2: Producto sin stock
    if (!producto || !producto.activo) {
      throw new Error("El producto seleccionado no está disponible");
    }

    if (producto.stockActual < cantidad) {
      throw new Error("El producto seleccionado está sin stock");
    }

    // Paso 5: Verificar si el producto ya está en el pedido
    const productoExistente = await this.productoPedidoRepository.findOne({
      where: {
        idPedido,
        idProducto
      }
    });

    let productoPedido: ProductoPedido;
    const precioUnitario = producto.precio;

    if (productoExistente) {
      // Si ya existe, actualizar cantidad y subtotal
      const nuevaCantidad = productoExistente.cantidad + cantidad;
      
      // Validar que la nueva cantidad total no supere el stock
      if (producto.stockActual < nuevaCantidad) {
        throw new Error("El producto seleccionado está sin stock");
      }

      const nuevoSubtotal = nuevaCantidad * precioUnitario;
      
      await this.productoPedidoRepository.update(
        productoExistente.idProductoPedido,
        {
          cantidad: nuevaCantidad,
          subtotal: nuevoSubtotal,
          precioUnitario // Actualizar precio por si cambió
        }
      );

      productoPedido = await this.productoPedidoRepository.findById(
        productoExistente.idProductoPedido
      ) as ProductoPedido;
    } else {
      // Paso 6: Agregar nuevo producto al pedido
      const subtotal = cantidad * precioUnitario;
      
      productoPedido = await this.productoPedidoRepository.create({
        idPedido,
        idProducto,
        cantidad,
        precioUnitario,
        subtotal
      });
    }

    // Paso 6: Actualizar el total del pedido
    const productosDelPedido = await this.productoPedidoRepository.findByPedido(idPedido);

    const nuevoTotal = productosDelPedido.reduce(
      (sum, prod) => sum + Number(prod.subtotal),
      0
    );

    await this.pedidoRepository.update(idPedido, {
      total: nuevoTotal
    });

    const pedidoActualizado = await this.pedidoRepository.findById(idPedido) as Pedido;

    // Paso 7: Retornar pedido actualizado
    return {
      pedido: pedidoActualizado,
      productoPedido,
      mensaje: "Producto agregado al pedido exitosamente"
    };
  }

  /**
   * Obtener un pedido por ID con sus productos
   * 
   * @param idPedido - ID del pedido
   * @returns Pedido con sus productos
   */
  async obtenerPedidoPorId(idPedido: number): Promise<Pedido | null> {
    const pedido = await this.pedidoRepository.findById(idPedido);
    return pedido;
  }

  /**
   * Obtener productos de un pedido específico
   * 
   * @param idPedido - ID del pedido
   * @returns Array de productos del pedido
   */
  async obtenerProductosDePedido(idPedido: number): Promise<ProductoPedido[]> {
    return await this.productoPedidoRepository.findByPedido(idPedido);
  }

  /**
   * CU033 - Consultar pedidos anteriores
   * Obtener historial de pedidos de un cliente con filtros opcionales
   * 
   * @param idUsuario - ID del usuario cliente
   * @param filtros - Filtros opcionales (fechas, estado, método de pago)
   * @returns Array de pedidos del cliente ordenados por fecha descendente
   */
  async obtenerHistorialPedidos(
    idUsuario: number,
    filtros?: {
      fechaInicio?: Date;
      fechaFin?: Date;
      estado?: string;
      idMetodoPago?: number;
    }
  ): Promise<Pedido[]> {
    const whereConditions: any = { 
      idUsuario,
      estado: { $ne: 'sin_confirmar' } // Excluir carritos sin confirmar del historial
    };

    // Aplicar filtro de rango de fechas si se proporciona
    if (filtros?.fechaInicio && filtros?.fechaFin) {
      whereConditions.fechaPedido = {
        $gte: filtros.fechaInicio,
        $lte: filtros.fechaFin
      };
    }

    // Aplicar filtro de estado si se proporciona
    if (filtros?.estado) {
      whereConditions.estado = filtros.estado;
    }

    const pedidos = await this.pedidoRepository.findAll({
      where: whereConditions,
      order: [['fechaPedido', 'DESC']]
    });

    return pedidos;
  }

  /**
   * CU033 - Consultar detalle de un pedido específico
   * Validando que el pedido pertenezca al usuario solicitante
   * 
   * @param idPedido - ID del pedido
   * @param idUsuario - ID del usuario que solicita el detalle
   * @returns Pedido con todos sus detalles o null si no existe o no pertenece al usuario
   */
  async obtenerDetallePedidoCliente(
    idPedido: number,
    idUsuario: number
  ): Promise<Pedido | null> {
    const pedido = await this.pedidoRepository.findOne({
      where: {
        idPedido,
        idUsuario // Validar que el pedido pertenezca al usuario
      }
    });

    return pedido;
  }

  /**
   * CU034 - Consultar estado de pedido actual
   * Obtener pedidos en curso del cliente (estado 'pendiente')
   * 
   * @param idUsuario - ID del usuario cliente
   * @returns Array de pedidos en curso
   */
  async obtenerPedidosEnCurso(idUsuario: number): Promise<Pedido[]> {
    const pedidosEnCurso = await this.pedidoRepository.findAll({
      where: {
        idUsuario,
        estado: 'pendiente' // Solo pedidos en proceso
      },
      order: [['fechaPedido', 'DESC']]
    });

    return pedidosEnCurso;
  }

  /**
   * CU034 - Consultar estado de un pedido específico por ID
   * Validando que el pedido pertenezca al usuario solicitante
   * 
   * @param idPedido - ID del pedido
   * @param idUsuario - ID del usuario que solicita el estado
   * @returns Pedido o null si no existe o no pertenece al usuario
   */
  async consultarEstadoPedido(
    idPedido: number,
    idUsuario: number
  ): Promise<Pedido | null> {
    const pedido = await this.pedidoRepository.findOne({
      where: {
        idPedido,
        idUsuario
      }
    });

    return pedido;
  }

  /**
   * CU38 - Marcar estado de un pedido
   * Permite a empleados cambiar el estado de un pedido con validaciones
   * 
   * @param idPedido - ID del pedido a actualizar
   * @param nuevoEstado - Nuevo estado del pedido
   * @returns Pedido actualizado
   */
  async marcarEstadoPedido(
    idPedido: number,
    nuevoEstado: string
  ): Promise<Pedido> {
    // Obtener el pedido actual
    const pedido = await this.pedidoRepository.findById(idPedido);

    // Excepción E2: Pedido no existe o fue eliminado
    if (!pedido) {
      throw new Error("El pedido seleccionado no existe o fue eliminado");
    }

    const estadoActual = pedido.estado;

    // Validar que el estado nuevo sea válido
    const estadosValidos = ['sin_confirmar', 'pendiente', 'entregado', 'cancelado'];
    if (!estadosValidos.includes(nuevoEstado)) {
      throw new Error("Estado no válido");
    }

    // Flujo alterno 2: Si el pedido ya está entregado, no se puede modificar
    if (estadoActual === 'entregado') {
      throw new Error("El pedido ya está en estado 'Entregado'. No se permiten modificaciones adicionales");
    }

    // Flujo alterno 2: Si el pedido ya está cancelado, no se puede modificar
    if (estadoActual === 'cancelado') {
      throw new Error("El pedido ya está cancelado. No se permiten modificaciones adicionales");
    }

    // Flujo alterno 1: Validar transiciones de estado permitidas
    const transicionesValidas: { [key: string]: string[] } = {
      'sin_confirmar': ['pendiente', 'cancelado'],
      'pendiente': ['entregado', 'cancelado'],
      'entregado': [],
      'cancelado': []
    };

    if (!transicionesValidas[estadoActual]?.includes(nuevoEstado)) {
      throw new Error(
        `Transición de estado no permitida: no se puede cambiar de '${estadoActual}' a '${nuevoEstado}'`
      );
    }

    // Validación adicional: Si se intenta marcar como pendiente, debe tener pago registrado
    if (nuevoEstado === 'pendiente') {
      const pago = await this.pagoRepository.findOne({
        where: { idPedido }
      });

      if (!pago) {
        throw new Error("El pedido debe tener un pago registrado para poder marcarse como pendiente");
      }
    }

    // Actualizar el estado del pedido
    await this.pedidoRepository.update(idPedido, {
      estado: nuevoEstado
    });

    // Obtener el pedido actualizado
    const pedidoActualizado = await this.pedidoRepository.findById(idPedido) as Pedido;

    return pedidoActualizado;
  }

  /**
   * Listar todos los pedidos (para empleados)
   * 
   * @returns Array de todos los pedidos
   */
  async listarTodosPedidos(): Promise<Pedido[]> {
    const pedidos = await this.pedidoRepository.findAll({
      order: [['fechaPedido', 'DESC']]
    });

    return pedidos;
  }

  /**
   * CU48 - Realizar pedido del cliente
   * Permite a empleados crear pedidos presenciales (en mesa o para llevar)
   * 
   * @param idUsuarioEmpleado - ID del empleado que registra el pedido
   * @param productos - Array de productos con cantidades
   * @param idMesa - ID de la mesa (opcional, si es para llevar no se envía)
   * @param accessToken - Token de acceso para validaciones
   * @returns Pedido creado con productos y ruta del PDF generado
   */
  async realizarPedidoCliente(
    idUsuarioEmpleado: number,
    productos: ProductoPedidoInput[],
    idMesa?: number,
    accessToken?: string
  ): Promise<CrearPedidoClienteResult> {
    
    // Precondición 3: Validar que existan productos
    if (!productos || productos.length === 0) {
      throw new Error("Debe seleccionar al menos un producto");
    }

    // Paso 4-5: Validar productos disponibles y obtener información
    const productosValidados = [];
    for (const item of productos) {
      // Validar cantidad
      if (item.cantidad <= 0) {
        throw new Error("La cantidad debe ser mayor a 0");
      }

      // Obtener información del producto
      const producto = await this.inventoryService.getProductoById(item.idProducto, accessToken);
      
      // Flujo alterno 1: Producto no disponible
      if (!producto || !producto.activo) {
        throw new Error(`El producto con ID ${item.idProducto} no está disponible`);
      }

      // Flujo alterno 1: Validar stock
      if (producto.stockActual < item.cantidad) {
        throw new Error(`Stock insuficiente para el producto ${item.idProducto}. Stock disponible: ${producto.stockActual}`);
      }

      productosValidados.push({
        idProducto: item.idProducto,
        cantidad: item.cantidad,
        precioUnitario: producto.precio
      });
    }

    // Paso 3: Validar mesa si se proporciona (pedido en mesa)
    let nombreMesa: string | undefined;
    if (idMesa) {
      try {
        const mesas = await this.tableService.getAllMesas(accessToken);
        const mesa = mesas.find(m => m.idMesa === idMesa);
        
        // Precondición 4: La mesa debe existir
        if (!mesa) {
          throw new Error(`La mesa con ID ${idMesa} no existe`);
        }

        // Validar que la mesa esté disponible
        if (mesa.estado !== 'Disponible') {
          throw new Error(`La mesa ${mesa.numeroMesa} no está disponible. Estado actual: ${mesa.estado}`);
        }

        nombreMesa = `Mesa ${mesa.numeroMesa}`;
      } catch (error: any) {
        // Flujo alterno 3: Error de conexión
        if (error.message.includes("Error al obtener mesas") || 
            error.message.includes("rechazó la autenticación")) {
          throw new Error("Error de conexión al servicio de mesas. Intente nuevamente");
        }
        throw error;
      }
    }

    // Paso 6-7: Crear pedido
    const pedido = await this.pedidoRepository.create({
      idUsuario: idUsuarioEmpleado,
      total: 0, // Se calculará después
      estado: 'sin_confirmar',
      canalVenta: 'fisico',
      fechaPedido: new Date(),
      idMesa: idMesa
    });

    // Paso 5: Agregar productos al pedido
    const productosCreados: ProductoPedido[] = [];
    let totalPedido = 0;

    for (const item of productosValidados) {
      const subtotal = item.precioUnitario * item.cantidad;
      
      const productoPedido = await this.productoPedidoRepository.create({
        idPedido: pedido.idPedido,
        idProducto: item.idProducto,
        cantidad: item.cantidad,
        precioUnitario: item.precioUnitario,
        subtotal: subtotal
      });

      productosCreados.push(productoPedido);
      totalPedido += subtotal;
    }

    // Paso 6: Actualizar total del pedido
    await this.pedidoRepository.update(pedido.idPedido, {
      total: totalPedido
    });

    const pedidoActualizado = await this.pedidoRepository.findById(pedido.idPedido) as Pedido;

    // Paso 8: Generar recibo PDF
    let rutaPDF: string;
    try {
      rutaPDF = await generarReciboPDF({
        pedido: pedidoActualizado,
        productos: productosCreados,
        nombreMesa: nombreMesa
      });
    } catch (error: any) {
      // Si falla la generación del PDF, continuar pero notificar
      console.error("Error al generar PDF:", error);
      throw new Error("Pedido creado pero error al generar recibo PDF");
    }

    // Postcondición: Actualizar estado de la mesa si aplica (solo pedidos en mesa)
    if (idMesa) {
      try {
        await this.tableService.updateMesaEstado(idMesa, { estado: 'Ocupada' }, accessToken);
      } catch (error: any) {
        // Flujo alterno 3: Error de conexión
        console.error("Error al actualizar estado de mesa:", error);
        throw new Error("Pedido creado pero error al actualizar estado de la mesa");
      }
    }

    // Paso 9: Retornar confirmación
    return {
      pedido: pedidoActualizado,
      productos: productosCreados,
      rutaPDF: rutaPDF,
      mensaje: "Pedido registrado exitosamente"
    };
  }

  /**
   * Eliminar un producto del carrito
   * Solo permitido si el pedido está en estado 'sin_confirmar'
   */
  async eliminarProductoDelCarrito(
    idProductoPedido: number,
    idUsuario: number
  ): Promise<ServiceResult<{ mensaje: string }>> {
    try {
      // Buscar el producto del pedido
      const productoPedido = await ProductoPedido.findByPk(idProductoPedido, {
        include: [{ model: Pedido }]
      });

      if (!productoPedido) {
        return { 
          status: 404, 
          message: 'Producto no encontrado en el pedido' 
        };
      }

      const pedido = productoPedido.pedido;

      // Validar que el pedido pertenezca al usuario
      if (pedido.idUsuario !== idUsuario) {
        return { 
          status: 403, 
          message: 'No tienes permiso para modificar este pedido' 
        };
      }

      // Validar que el pedido esté en estado 'sin_confirmar'
      if (pedido.estado !== 'sin_confirmar') {
        return { 
          status: 400, 
          message: 'Solo se pueden modificar pedidos en estado sin confirmar' 
        };
      }

      // Eliminar el producto
      const subtotalEliminado = productoPedido.subtotal;
      await productoPedido.destroy();

      // Recalcular el total del pedido
      const nuevoTotal = pedido.total - subtotalEliminado;
      await this.pedidoRepository.update(pedido.idPedido, {
        total: nuevoTotal
      });

      return {
        status: 200,
        message: 'Producto eliminado del carrito',
        data: { mensaje: 'Producto eliminado exitosamente' }
      };
    } catch (error: any) {
      return { 
        status: 500, 
        message: `Error al eliminar producto: ${error.message}` 
      };
    }
  }

  /**
   * Vaciar el carrito completo
   * Elimina el pedido en estado 'sin_confirmar'
   */
  async vaciarCarrito(idUsuario: number): Promise<ServiceResult<{ mensaje: string }>> {
    try {
      // Buscar el pedido en estado 'sin_confirmar' del usuario
      const pedido = await Pedido.findOne({
        where: {
          idUsuario: idUsuario,
          estado: 'sin_confirmar'
        },
        include: [{ model: Pago }]
      });

      if (!pedido) {
        return { 
          status: 404, 
          message: 'No tienes un carrito activo' 
        };
      }

      // Verificar que no tenga pagos asociados
      if (pedido.pagos && pedido.pagos.length > 0) {
        return {
          status: 400,
          message: 'No se puede vaciar un carrito que ya tiene pagos registrados'
        };
      }

      // Eliminar el pedido (cascade eliminará los productos)
      await pedido.destroy();

      return {
        status: 200,
        message: 'Carrito vaciado exitosamente',
        data: { mensaje: 'Carrito eliminado' }
      };
    } catch (error: any) {
      return { 
        status: 500, 
        message: `Error al vaciar carrito: ${error.message}` 
      };
    }
  }

  /**
   * Cancelar un pedido
   * El cliente puede cancelar pedidos en estado 'sin_confirmar' o 'pendiente'
   */
  async cancelarPedido(
    idPedido: number,
    idUsuario: number
  ): Promise<ServiceResult<{ mensaje: string }>> {
    try {
      // Buscar el pedido
      const pedido = await this.pedidoRepository.findById(idPedido);

      if (!pedido) {
        return { 
          status: 404, 
          message: 'Pedido no encontrado' 
        };
      }

      // Validar que el pedido pertenezca al usuario
      if (pedido.idUsuario !== idUsuario) {
        return { 
          status: 403, 
          message: 'No tienes permiso para cancelar este pedido' 
        };
      }

      // Validar que el pedido esté en estado cancelable
      if (pedido.estado !== 'sin_confirmar' && pedido.estado !== 'pendiente') {
        return { 
          status: 400, 
          message: 'Solo se pueden cancelar pedidos sin confirmar o pendientes' 
        };
      }

      // Cambiar estado a 'cancelado'
      await this.pedidoRepository.update(idPedido, {
        estado: 'cancelado'
      });

      return {
        status: 200,
        message: 'Pedido cancelado exitosamente',
        data: { mensaje: 'Pedido cancelado' }
      };
    } catch (error: any) {
      return { 
        status: 500, 
        message: `Error al cancelar pedido: ${error.message}` 
      };
    }
  }

  /**
   * Eliminar un producto de una orden (empleado/admin)
   * Permite eliminar productos de pedidos presenciales
   */
  async eliminarProductoDeOrden(
    idProductoPedido: number
  ): Promise<ServiceResult<{ mensaje: string }>> {
    try {
      // Buscar el producto del pedido
      const productoPedido = await ProductoPedido.findByPk(idProductoPedido, {
        include: [{ model: Pedido }]
      });

      if (!productoPedido) {
        return { 
          status: 404, 
          message: 'Producto no encontrado en el pedido' 
        };
      }

      const pedido = productoPedido.pedido;

      // No permitir modificar pedidos ya finalizados
      if (pedido.estado === 'entregado' || pedido.estado === 'cancelado') {
        return { 
          status: 400, 
          message: 'No se pueden modificar pedidos entregados o cancelados' 
        };
      }

      // Eliminar el producto
      const subtotalEliminado = productoPedido.subtotal;
      await productoPedido.destroy();

      // Recalcular el total del pedido
      const nuevoTotal = pedido.total - subtotalEliminado;
      await this.pedidoRepository.update(pedido.idPedido, {
        total: nuevoTotal
      });

      return {
        status: 200,
        message: 'Producto eliminado del pedido',
        data: { mensaje: 'Producto eliminado exitosamente' }
      };
    } catch (error: any) {
      return { 
        status: 500, 
        message: `Error al eliminar producto: ${error.message}` 
      };
    }
  }

  /**
   * Eliminar una orden completa (empleado/admin)
   * Solo permite eliminar pedidos no finalizados
   */
  async eliminarOrden(idPedido: number): Promise<ServiceResult<{ mensaje: string }>> {
    try {
      // Buscar el pedido con sus pagos
      const pedido = await Pedido.findByPk(idPedido, {
        include: [{ model: Pago }]
      });

      if (!pedido) {
        return { 
          status: 404, 
          message: 'Pedido no encontrado' 
        };
      }

      // No permitir eliminar pedidos finalizados
      if (pedido.estado === 'entregado') {
        return { 
          status: 400, 
          message: 'No se pueden eliminar pedidos ya entregados' 
        };
      }

      // Verificar que no tenga pagos asociados
      if (pedido.pagos && pedido.pagos.length > 0) {
        return {
          status: 400,
          message: 'No se puede eliminar un pedido que tiene pagos registrados. Cancélelo en su lugar.'
        };
      }

      // Eliminar el pedido (cascade eliminará los productos)
      await pedido.destroy();

      return {
        status: 200,
        message: 'Pedido eliminado exitosamente',
        data: { mensaje: 'Pedido eliminado' }
      };
    } catch (error: any) {
      return { 
        status: 500, 
        message: `Error al eliminar pedido: ${error.message}` 
      };
    }
  }
}

