import { Request, Response } from "express";
import { PedidoService, ConfirmarPedidoData } from "../services/pedidoService";
import { extractToken } from "../utils/tokenExtractor";
import { validateAuthenticated, validateIntegerId, validateIntegerFields } from "../utils/validationHelper";

/**
 * Controlador para gestión de pedidos (carritos de compra)
 * Sigue patrón: Try-Catch en Capa de Controlador con Respuestas Estandarizadas
 */
export class PedidoController {
  private pedidoService: PedidoService;

  constructor() {
    this.pedidoService = new PedidoService();
  }

  /**
   * CU022 - Añadir productos al carrito
   * POST /api/pedido/carrito/producto
   */
  agregarProductoAlCarrito = async (req: Request, res: Response): Promise<void> => {
    try {
      const { idProducto, cantidad } = req.body;
      const idUsuario = validateAuthenticated(req, res);
      if (!idUsuario) return;

      // Validación de datos requeridos
      if (!idProducto || !cantidad) {
        res.status(400).json({ 
          success: false,
          message: "Faltan datos requeridos: idProducto y cantidad son obligatorios" 
        });
        return;
      }

      // Validación de tipos de datos
      if (!validateIntegerFields({ idProducto, cantidad }, ['idProducto', 'cantidad'], res)) {
        return;
      }

      const accessToken = extractToken(req);
      const resultado = await this.pedidoService.agregarProductoAlCarrito(
        idUsuario,
        idProducto,
        cantidad,
        accessToken
      );

      res.status(resultado.status).json(resultado.data || { success: false, message: resultado.message });
    } catch (error: any) {
      console.error("Error al añadir producto al carrito:", error);
      res.status(500).json({ 
        success: false,
        message: "Error al añadir producto al carrito",
        error: error.message 
      });
    }
  };

  /**
   * Obtener el carrito actual del usuario
   * GET /api/pedido/carrito
   */
  obtenerCarrito = async (req: Request, res: Response): Promise<void> => {
    try {
      const idUsuario = validateAuthenticated(req, res);
      if (!idUsuario) return;

      const carrito = await this.pedidoService.obtenerCarritoActual(idUsuario);

      if (!carrito) {
        res.status(200).json({
          success: true,
          message: "El carrito está vacío",
          data: null
        });
        return;
      }

      const productos = await this.pedidoService.obtenerProductosDelCarrito(idUsuario);

      res.status(200).json({
        success: true,
        data: {
          pedido: {
            idPedido: carrito.idPedido,
            total: carrito.total,
            estado: carrito.estado,
            fechaPedido: carrito.fechaPedido
          },
          productos: productos.map(p => ({
            idProductoPedido: p.idProductoPedido,
            idProducto: p.idProducto,
            cantidad: p.cantidad,
            precioUnitario: p.precioUnitario,
            subtotal: p.subtotal
          }))
        }
      });

    } catch (error: any) {
      console.error("Error al obtener carrito:", error);
      res.status(500).json({ 
        success: false,
        message: "Error al obtener el carrito",
        error: error.message 
      });
    }
  };

  /**
   * CU035 - Confirmar pedido (sin pago)
   * POST /api/pedido/confirmar
   * 
   * Confirma el carrito del usuario:
   * - Valida disponibilidad de productos
   * - Calcula total con promociones
   * - Reserva stock en inventario
   * - Cambia estado a 'pendiente'
   * - Prepara para pago posterior
   * 
   * Body (opcional):
   * {
   *   "direccionEntrega": string // Si no se proporciona, se usa la del cliente
   * }
   */
  confirmarPedido = async (req: Request, res: Response): Promise<void> => {
    try {
      const { direccionEntrega } = req.body;
      const idUsuario = validateAuthenticated(req, res);
      if (!idUsuario) return;

      const accessToken = extractToken(req);
      const datosConfirmacion: ConfirmarPedidoData = {
        direccionEntrega // Opcional
      };

      const resultado = await this.pedidoService.confirmarPedido(
        idUsuario,
        datosConfirmacion,
        accessToken
      );

      res.status(resultado.status).json(resultado.data || { success: false, message: resultado.message });
    } catch (error: any) {
      console.error("Error al confirmar pedido:", error);
      res.status(500).json({ 
        success: false,
        message: "Error al confirmar el pedido. Intente más tarde",
        error: error.message 
      });
    }
  };

  /**
   * CU37 - Agregar productos a un pedido
   * POST /api/pedido/:idPedido/producto
   * 
   * Permite a empleados agregar productos a pedidos existentes
   * 
   * Body:
   * {
   *   "idProducto": number,
   *   "cantidad": number
   * }
   */
  agregarProductoAPedido = async (req: Request, res: Response): Promise<void> => {
    try {
      const { idProducto, cantidad } = req.body;
      const idPedido = parseInt(req.params.idPedido);

      // Validación de parámetros
      if (isNaN(idPedido)) {
        res.status(400).json({ 
          success: false,
          message: "El ID del pedido debe ser un número válido" 
        });
        return;
      }

      // Validación de datos requeridos
      if (!idProducto || !cantidad) {
        res.status(400).json({ 
          success: false,
          message: "Faltan datos requeridos: idProducto y cantidad son obligatorios" 
        });
        return;
      }

      // Validación de tipos de datos
      if (!Number.isInteger(idProducto) || !Number.isInteger(cantidad)) {
        res.status(400).json({ 
          success: false,
          message: "idProducto y cantidad deben ser números enteros" 
        });
        return;
      }

      // Obtener access token
      const authHeader = req.headers.authorization;
      let accessToken: string | undefined;
      
      if (authHeader?.startsWith("Bearer ")) {
        accessToken = authHeader.replace("Bearer ", "").trim();
      } else {
        const cookieHeader = req.headers.cookie;
        if (cookieHeader) {
          const match = cookieHeader.match(/accessToken=([^;]+)/);
          if (match?.[1]) {
            accessToken = match[1];
          }
        }
      }

      // Llamar al servicio
      const resultado = await this.pedidoService.agregarProductoAPedido(
        idPedido,
        idProducto,
        cantidad,
        accessToken
      );

      // Obtener productos del pedido para el conteo
      const productos = await this.pedidoService.obtenerProductosDePedido(idPedido);

      res.status(200).json({
        success: true,
        message: resultado.mensaje,
        data: {
          pedido: {
            idPedido: resultado.pedido.idPedido,
            total: resultado.pedido.total,
            estado: resultado.pedido.estado,
            cantidadProductos: productos.length
          },
          productoPedido: {
            idProductoPedido: resultado.productoPedido.idProductoPedido,
            idProducto: resultado.productoPedido.idProducto,
            cantidad: resultado.productoPedido.cantidad,
            precioUnitario: resultado.productoPedido.precioUnitario,
            subtotal: resultado.productoPedido.subtotal
          }
        }
      });

    } catch (error: any) {
      console.error("Error al agregar producto al pedido:", error);

      // Pedido no existe
      if (error.message === "El pedido no existe") {
        res.status(404).json({ 
          success: false,
          message: error.message 
        });
        return;
      }

      // Flujo alterno 2: Pedido finalizado/cancelado
      if (error.message === "No se pueden agregar productos a un pedido cancelado") {
        res.status(400).json({ 
          success: false,
          message: error.message 
        });
        return;
      }

      // Excepción 2: Producto sin stock
      if (error.message === "El producto seleccionado está sin stock" ||
          error.message === "El producto seleccionado no está disponible") {
        res.status(400).json({ 
          success: false,
          message: error.message 
        });
        return;
      }

      if (error.message === "La cantidad debe ser mayor a 0") {
        res.status(400).json({ 
          success: false,
          message: error.message 
        });
        return;
      }

      // Error genérico
      res.status(500).json({ 
        success: false,
        message: "Error al agregar producto al pedido",
        error: error.message 
      });
    }
  };

  /**
   * Obtener un pedido por ID
   * GET /api/pedido/:idPedido
   */
  obtenerPedidoPorId = async (req: Request, res: Response): Promise<void> => {
    try {
      const idPedido = parseInt(req.params.idPedido);

      if (isNaN(idPedido)) {
        res.status(400).json({ 
          success: false,
          message: "El ID del pedido debe ser un número válido" 
        });
        return;
      }

      const pedido = await this.pedidoService.obtenerPedidoPorId(idPedido);

      if (!pedido) {
        res.status(404).json({
          success: false,
          message: "El pedido no existe"
        });
        return;
      }

      const productos = await this.pedidoService.obtenerProductosDePedido(idPedido);

      res.status(200).json({
        success: true,
        data: {
          pedido: {
            idPedido: pedido.idPedido,
            total: pedido.total,
            estado: pedido.estado,
            canalVenta: pedido.canalVenta,
            fechaPedido: pedido.fechaPedido,
            direccionEntrega: pedido.direccionEntrega,
            idUsuario: pedido.idUsuario
          },
          productos: productos.map(p => ({
            idProductoPedido: p.idProductoPedido,
            idProducto: p.idProducto,
            cantidad: p.cantidad,
            precioUnitario: p.precioUnitario,
            subtotal: p.subtotal
          }))
        }
      });

    } catch (error: any) {
      console.error("Error al obtener pedido:", error);
      res.status(500).json({ 
        success: false,
        message: "Error al obtener el pedido",
        error: error.message 
      });
    }
  };

  /**
   * CU033 - Consultar pedidos anteriores
   * GET /api/pedido/historial
   * 
   * Query params opcionales:
   * - fechaInicio: Date (formato ISO)
   * - fechaFin: Date (formato ISO)
   * - estado: string (pendiente, entregado, cancelado)
   * - idMetodoPago: number
   */
  listarHistorialPedidos = async (req: Request, res: Response): Promise<void> => {
    try {
      const idUsuario = req.user?.id;

      // Validación de usuario autenticado
      if (!idUsuario) {
        res.status(401).json({ 
          success: false,
          message: "Usuario no autenticado" 
        });
        return;
      }

      // Construir filtros opcionales desde query params
      const filtros: any = {};

      if (req.query.fechaInicio && req.query.fechaFin) {
        filtros.fechaInicio = new Date(req.query.fechaInicio as string);
        filtros.fechaFin = new Date(req.query.fechaFin as string);

        // Validar que las fechas sean válidas
        if (isNaN(filtros.fechaInicio.getTime()) || isNaN(filtros.fechaFin.getTime())) {
          res.status(400).json({
            success: false,
            message: "Formato de fecha inválido. Use formato ISO (YYYY-MM-DD)"
          });
          return;
        }

        // Validar que fechaInicio sea anterior a fechaFin
        if (filtros.fechaInicio > filtros.fechaFin) {
          res.status(400).json({
            success: false,
            message: "La fecha de inicio debe ser anterior a la fecha de fin"
          });
          return;
        }
      }

      if (req.query.estado) {
        const estadosValidos = ['pendiente', 'entregado', 'cancelado'];
        const estado = req.query.estado as string;
        
        if (!estadosValidos.includes(estado)) {
          res.status(400).json({
            success: false,
            message: `Estado inválido. Estados válidos: ${estadosValidos.join(', ')}`
          });
          return;
        }
        
        filtros.estado = estado;
      }

      if (req.query.idMetodoPago) {
        const idMetodoPago = parseInt(req.query.idMetodoPago as string);
        
        if (isNaN(idMetodoPago)) {
          res.status(400).json({
            success: false,
            message: "El idMetodoPago debe ser un número válido"
          });
          return;
        }
        
        filtros.idMetodoPago = idMetodoPago;
      }

      // Obtener historial de pedidos
      const pedidos = await this.pedidoService.obtenerHistorialPedidos(idUsuario, filtros);

      // Flujo alterno 2A: Si no hay pedidos anteriores
      if (pedidos.length === 0) {
        res.status(200).json({
          success: true,
          message: "No se encontraron pedidos anteriores",
          data: []
        });
        return;
      }

      // Formatear respuesta con información relevante del caso de uso
      const pedidosFormateados = await Promise.all(pedidos.map(async (pedido) => {
        // Obtener productos del pedido
        const productos = await this.pedidoService.obtenerProductosDePedido(pedido.idPedido);
        
        return {
          idPedido: pedido.idPedido,
          total: pedido.total,
          estado: pedido.estado,
          canalVenta: pedido.canalVenta,
          fechaPedido: pedido.fechaPedido,
          direccionEntrega: pedido.direccionEntrega,
          cantidadProductos: productos.length
        };
      }));

      res.status(200).json({
        success: true,
        message: "Historial de pedidos obtenido exitosamente",
        data: pedidosFormateados,
        total: pedidosFormateados.length
      });

    } catch (error: any) {
      console.error("Error al obtener historial de pedidos:", error);
      
      // Excepción E1: Error al cargar datos
      res.status(500).json({
        success: false,
        message: "Error al cargar los pedidos. Intente nuevamente",
        error: error.message
      });
    }
  };

  /**
   * CU033 - Consultar detalle de un pedido específico
   * GET /api/pedido/:idPedido/detalle
   * 
   * Validación adicional: verifica que el pedido pertenezca al usuario autenticado
   */
  obtenerDetallePedidoCliente = async (req: Request, res: Response): Promise<void> => {
    try {
      const idUsuario = req.user?.id;
      const { idPedido } = req.params;

      // Validación de usuario autenticado
      if (!idUsuario) {
        res.status(401).json({ 
          success: false,
          message: "Usuario no autenticado" 
        });
        return;
      }

      // Validación de parámetro
      const idPedidoNumero = parseInt(idPedido);
      if (isNaN(idPedidoNumero)) {
        res.status(400).json({
          success: false,
          message: "ID de pedido inválido"
        });
        return;
      }

      // Obtener pedido validando que pertenezca al usuario
      const pedido = await this.pedidoService.obtenerDetallePedidoCliente(
        idPedidoNumero,
        idUsuario
      );

      if (!pedido) {
        res.status(404).json({
          success: false,
          message: "Pedido no encontrado o no tiene acceso a este pedido"
        });
        return;
      }

      // Obtener productos del pedido según requisitos del caso de uso
      const productos = await this.pedidoService.obtenerProductosDePedido(pedido.idPedido);

      // Formatear respuesta con información del caso de uso: productos, cantidades, precios, estado y fecha
      res.status(200).json({
        success: true,
        message: "Detalle del pedido obtenido exitosamente",
        data: {
          idPedido: pedido.idPedido,
          total: pedido.total,
          estado: pedido.estado,
          canalVenta: pedido.canalVenta,
          fechaPedido: pedido.fechaPedido,
          direccionEntrega: pedido.direccionEntrega,
          productos: productos.map(p => ({
            idProductoPedido: p.idProductoPedido,
            idProducto: p.idProducto,
            cantidad: p.cantidad,
            precioUnitario: p.precioUnitario,
            subtotal: p.subtotal
          }))
        }
      });

    } catch (error: any) {
      console.error("Error al obtener detalle del pedido:", error);
      
      // Excepción E1: Error al cargar datos
      res.status(500).json({
        success: false,
        message: "Error al cargar los pedidos. Intente nuevamente",
        error: error.message
      });
    }
  };

  /**
   * CU034 - Consultar estado de pedido actual
   * GET /api/pedido/en-curso
   * 
   * Obtiene la lista de pedidos en curso del cliente (estado 'pendiente')
   */
  listarPedidosEnCurso = async (req: Request, res: Response): Promise<void> => {
    try {
      const idUsuario = req.user?.id;

      // Validación de usuario autenticado
      if (!idUsuario) {
        res.status(401).json({ 
          success: false,
          message: "Usuario no autenticado" 
        });
        return;
      }

      // Obtener pedidos en curso
      const pedidosEnCurso = await this.pedidoService.obtenerPedidosEnCurso(idUsuario);

      // Flujo alterno 2A: Si no tiene pedidos en curso
      if (pedidosEnCurso.length === 0) {
        res.status(200).json({
          success: true,
          message: "No tiene pedidos ni reservas en curso",
          data: []
        });
        return;
      }

      // Formatear respuesta con información del caso de uso
      const pedidosFormateados = pedidosEnCurso.map(pedido => ({
        idPedido: pedido.idPedido,
        total: pedido.total,
        estado: pedido.estado,
        canalVenta: pedido.canalVenta,
        fechaPedido: pedido.fechaPedido,
        direccionEntrega: pedido.direccionEntrega
      }));

      res.status(200).json({
        success: true,
        message: "Pedidos en curso obtenidos exitosamente",
        data: pedidosFormateados
      });

    } catch (error: any) {
      console.error("Error al obtener pedidos en curso:", error);
      
      // Excepción E1: Error al consultar el estado
      res.status(500).json({
        success: false,
        message: "Error al consultar el estado. Intente más tarde",
        error: error.message
      });
    }
  };

  /**
   * CU034 - Consultar estado de un pedido específico por ID
   * GET /api/pedido/estado/:idPedido
   * 
   * Permite al cliente consultar el estado de un pedido específico
   */
  consultarEstadoPedido = async (req: Request, res: Response): Promise<void> => {
    try {
      const idUsuario = req.user?.id;
      const { idPedido } = req.params;

      // Validación de usuario autenticado
      if (!idUsuario) {
        res.status(401).json({ 
          success: false,
          message: "Usuario no autenticado" 
        });
        return;
      }

      // Validación de parámetro
      const idPedidoNumero = parseInt(idPedido);
      if (isNaN(idPedidoNumero)) {
        res.status(400).json({
          success: false,
          message: "ID de pedido inválido"
        });
        return;
      }

      // Consultar estado del pedido
      const pedido = await this.pedidoService.consultarEstadoPedido(
        idPedidoNumero,
        idUsuario
      );

      // Flujo alterno 4A: Número no válido o no pertenece al usuario
      if (!pedido) {
        res.status(404).json({
          success: false,
          message: "Número no válido. Verifique e intente nuevamente"
        });
        return;
      }

      // Formatear respuesta con estado del pedido
      res.status(200).json({
        success: true,
        message: "Estado del pedido obtenido exitosamente",
        data: {
          idPedido: pedido.idPedido,
          estado: pedido.estado,
          total: pedido.total,
          canalVenta: pedido.canalVenta,
          fechaPedido: pedido.fechaPedido,
          direccionEntrega: pedido.direccionEntrega
        }
      });

    } catch (error: any) {
      console.error("Error al consultar estado del pedido:", error);
      
      // Excepción E1: Error al consultar el estado
      res.status(500).json({
        success: false,
        message: "Error al consultar el estado. Intente más tarde",
        error: error.message
      });
    }
  };

  /**
   * CU38 - Marcar estado de un pedido
   * PATCH /api/pedido/:idPedido/estado
   * 
   * Body:
   * {
   *   "nuevoEstado": "pendiente" | "entregado" | "cancelado"
   * }
   */
  marcarEstadoPedido = async (req: Request, res: Response): Promise<void> => {
    try {
      const { idPedido } = req.params;
      const { nuevoEstado } = req.body;

      // Validación de parámetro
      const idPedidoNumero = parseInt(idPedido);
      if (isNaN(idPedidoNumero)) {
        res.status(400).json({
          success: false,
          message: "ID de pedido inválido"
        });
        return;
      }

      // Validación de datos requeridos
      if (!nuevoEstado) {
        res.status(400).json({
          success: false,
          message: "El campo 'nuevoEstado' es requerido"
        });
        return;
      }

      // Actualizar estado del pedido
      const pedidoActualizado = await this.pedidoService.marcarEstadoPedido(
        idPedidoNumero,
        nuevoEstado
      );

      res.status(200).json({
        success: true,
        message: "Estado del pedido actualizado exitosamente",
        data: {
          idPedido: pedidoActualizado.idPedido,
          estadoAnterior: req.body.estadoAnterior, // Si se envía para referencia
          estadoActual: pedidoActualizado.estado,
          total: pedidoActualizado.total,
          fechaPedido: pedidoActualizado.fechaPedido
        }
      });

    } catch (error: any) {
      console.error("Error al marcar estado del pedido:", error);

      // Flujo alterno 1: Estado inválido o transición no permitida
      if (error.message.includes("Estado no válido") || 
          error.message.includes("Transición de estado no permitida")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Flujo alterno 2: Pedido ya entregado o cancelado
      if (error.message.includes("ya está en estado") || 
          error.message.includes("ya está cancelado")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Validación de pago
      if (error.message.includes("debe tener un pago registrado")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Excepción E2: Pedido no existe o fue eliminado
      if (error.message.includes("no existe o fue eliminado")) {
        res.status(404).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Excepción E1: Error de conexión o del servidor
      res.status(500).json({
        success: false,
        message: "Error al actualizar el estado del pedido. Intente nuevamente",
        error: error.message
      });
    }
  };

  /**
   * Listar todos los pedidos (para empleados)
   * GET /api/pedido/todos
   */
  listarTodosPedidos = async (req: Request, res: Response): Promise<void> => {
    try {
      const pedidos = await this.pedidoService.listarTodosPedidos();

      res.status(200).json({
        success: true,
        message: "Lista de pedidos obtenida exitosamente",
        data: pedidos.map(p => ({
          idPedido: p.idPedido,
          idUsuario: p.idUsuario,
          total: p.total,
          estado: p.estado,
          canalVenta: p.canalVenta,
          fechaPedido: p.fechaPedido,
          direccionEntrega: p.direccionEntrega
        })),
        total: pedidos.length
      });

    } catch (error: any) {
      console.error("Error al listar pedidos:", error);
      res.status(500).json({
        success: false,
        message: "Error al obtener la lista de pedidos",
        error: error.message
      });
    }
  };

  /**
   * CU48 - Realizar pedido del cliente
   * POST /api/pedido/crear-pedido-cliente
   * 
   * Permite a empleados registrar pedidos presenciales (en mesa o para llevar)
   * 
   * Body:
   * {
   *   "productos": [
   *     {
   *       "idProducto": number,
   *       "cantidad": number
   *     }
   *   ],
   *   "idMesa": number (opcional, si no se envía es para llevar)
   * }
   */
  realizarPedidoCliente = async (req: Request, res: Response): Promise<void> => {
    try {
      const { productos, idMesa } = req.body;
      const idUsuarioEmpleado = req.user?.id;

      // Excepción 1: Validación de permisos (validado por middleware)
      if (!idUsuarioEmpleado) {
        res.status(401).json({
          success: false,
          message: "Usuario no autenticado"
        });
        return;
      }

      // Precondición 3: Validar que existan productos
      if (!productos || !Array.isArray(productos) || productos.length === 0) {
        res.status(400).json({
          success: false,
          message: "Debe proporcionar al menos un producto"
        });
        return;
      }

      // Validar estructura de productos
      for (const producto of productos) {
        if (!producto.idProducto || !producto.cantidad) {
          res.status(400).json({
            success: false,
            message: "Cada producto debe tener 'idProducto' y 'cantidad'"
          });
          return;
        }

        if (!Number.isInteger(producto.idProducto) || !Number.isInteger(producto.cantidad)) {
          res.status(400).json({
            success: false,
            message: "Los campos 'idProducto' y 'cantidad' deben ser números enteros"
          });
          return;
        }

        if (producto.cantidad <= 0) {
          res.status(400).json({
            success: false,
            message: "La cantidad debe ser mayor a 0"
          });
          return;
        }
      }

      // Validar idMesa si se proporciona
      if (idMesa !== undefined && !Number.isInteger(idMesa)) {
        res.status(400).json({
          success: false,
          message: "El campo 'idMesa' debe ser un número entero"
        });
        return;
      }

      // Obtener access token
      const authHeader = req.headers.authorization;
      let accessToken: string | undefined;
      
      if (authHeader?.startsWith("Bearer ")) {
        accessToken = authHeader.replace("Bearer ", "").trim();
      } else {
        const cookieHeader = req.headers.cookie;
        if (cookieHeader) {
          const match = cookieHeader.match(/accessToken=([^;]+)/);
          if (match?.[1]) {
            accessToken = match[1];
          }
        }
      }

      // Llamar al servicio
      const resultado = await this.pedidoService.realizarPedidoCliente(
        idUsuarioEmpleado,
        productos,
        idMesa,
        accessToken
      );

      // Paso 9: Retornar respuesta exitosa
      res.status(201).json({
        success: true,
        message: resultado.mensaje,
        data: {
          pedido: {
            idPedido: resultado.pedido.idPedido,
            total: resultado.pedido.total,
            estado: resultado.pedido.estado,
            canalVenta: resultado.pedido.canalVenta,
            fechaPedido: resultado.pedido.fechaPedido,
            idMesa: resultado.pedido.idMesa,
            tipoPedido: resultado.pedido.idMesa ? 'Mesa' : 'Para llevar'
          },
          productos: resultado.productos.map(p => ({
            idProductoPedido: p.idProductoPedido,
            idProducto: p.idProducto,
            cantidad: p.cantidad,
            precioUnitario: p.precioUnitario,
            subtotal: p.subtotal
          })),
          rutaPDF: resultado.rutaPDF
        }
      });

    } catch (error: any) {
      console.error("Error al realizar pedido del cliente:", error);

      // Flujo alterno 1: Producto no disponible
      if (error.message.includes("no está disponible")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Flujo alterno 1: Stock insuficiente
      if (error.message.includes("Stock insuficiente")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Validación de mesa
      if (error.message.includes("mesa") || error.message.includes("Mesa")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Error al generar PDF
      if (error.message.includes("error al generar recibo PDF")) {
        res.status(201).json({
          success: true,
          message: "Pedido creado exitosamente pero no se pudo generar el recibo PDF",
          warning: error.message
        });
        return;
      }

      // Error al actualizar mesa
      if (error.message.includes("error al actualizar estado de la mesa")) {
        res.status(201).json({
          success: true,
          message: "Pedido creado exitosamente pero no se pudo actualizar el estado de la mesa",
          warning: error.message
        });
        return;
      }

      // Flujo alterno 3: Error de conexión
      if (error.message.includes("Error de conexión")) {
        res.status(503).json({
          success: false,
          message: error.message
        });
        return;
      }

      // Excepción 2: Error del servidor
      res.status(500).json({
        success: false,
        message: "Error al registrar el pedido. Intente nuevamente",
        error: error.message
      });
    }
  };

  /**
   * Eliminar un producto del carrito
   * DELETE /api/pedido/cart/product/:idProductoPedido
   */
  eliminarProductoDelCarrito = async (req: Request, res: Response): Promise<void> => {
    try {
      const idProductoPedido = parseInt(req.params.idProductoPedido);
      const idUsuario = req.user!.id;

      if (isNaN(idProductoPedido)) {
        res.status(400).json({
          message: 'ID de producto inválido'
        });
        return;
      }

      const resultado = await this.pedidoService.eliminarProductoDelCarrito(
        idProductoPedido,
        idUsuario
      );

      res.status(resultado.status).json(resultado);
    } catch (error: any) {
      res.status(500).json({
        message: 'Error al eliminar producto del carrito',
        error: error.message
      });
    }
  };

  /**
   * Vaciar el carrito completo
   * DELETE /api/pedido/cart
   */
  vaciarCarrito = async (req: Request, res: Response): Promise<void> => {
    try {
      const idUsuario = req.user!.id;

      const resultado = await this.pedidoService.vaciarCarrito(idUsuario);

      res.status(resultado.status).json(resultado);
    } catch (error: any) {
      res.status(500).json({
        message: 'Error al vaciar carrito',
        error: error.message
      });
    }
  };

  /**
   * Cancelar un pedido
   * PATCH /api/pedido/:idPedido/cancel
   */
  cancelarPedido = async (req: Request, res: Response): Promise<void> => {
    try {
      const idPedido = parseInt(req.params.idPedido);
      const idUsuario = req.user!.id;

      if (isNaN(idPedido)) {
        res.status(400).json({
          message: 'ID de pedido inválido'
        });
        return;
      }

      const resultado = await this.pedidoService.cancelarPedido(idPedido, idUsuario);

      res.status(resultado.status).json(resultado);
    } catch (error: any) {
      res.status(500).json({
        message: 'Error al cancelar pedido',
        error: error.message
      });
    }
  };

  /**
   * Eliminar un producto de una orden (empleado/admin)
   * DELETE /api/pedido/:idPedido/product/:idProductoPedido
   */
  eliminarProductoDeOrden = async (req: Request, res: Response): Promise<void> => {
    try {
      const idProductoPedido = parseInt(req.params.idProductoPedido);

      if (isNaN(idProductoPedido)) {
        res.status(400).json({
          message: 'ID de producto inválido'
        });
        return;
      }

      const resultado = await this.pedidoService.eliminarProductoDeOrden(idProductoPedido);

      res.status(resultado.status).json(resultado);
    } catch (error: any) {
      res.status(500).json({
        message: 'Error al eliminar producto del pedido',
        error: error.message
      });
    }
  };

  /**
   * Eliminar una orden completa (empleado/admin)
   * DELETE /api/pedido/:idPedido
   */
  eliminarOrden = async (req: Request, res: Response): Promise<void> => {
    try {
      const idPedido = parseInt(req.params.idPedido);

      if (isNaN(idPedido)) {
        res.status(400).json({
          message: 'ID de pedido inválido'
        });
        return;
      }

      const resultado = await this.pedidoService.eliminarOrden(idPedido);

      res.status(resultado.status).json(resultado);
    } catch (error: any) {
      res.status(500).json({
        message: 'Error al eliminar pedido',
        error: error.message
      });
    }
  };

}

